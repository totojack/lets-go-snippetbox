# https://taskfile.dev

version: '3'

# Define the variables used across tasks
vars:
  GREETING: Hello, World!
  IMAGE_NAME: my-app-mysql
  IMAGE_TAG: latest
  CONTAINER_NAME: my-app-db
  MYSQL_ROOT_PASSWORD: password
  MYSQL_DATABASE: snippetbox
  MYSQL_PORT: 3306 # The port exposed on the host machine
  MYSQL_WEB_USER: web
  MYSQL_WEB_PASSWORD: pass
  ADMINER_CONTAINER_NAME: my-app-adminer
  ADMINER_PORT: 8080 # Port where Adminer web UI runs
  APP_PORT: 4000 # Port where the Go web application runs
  APP_PROCESS_NAME: snippetbox # Name to identify the running process
  RUNTIME_DIR: .runtime # Directory for runtime files (logs, PIDs)

tasks:
  # -------------------------------------------------------------------------
  # BASE SETUP
  # -------------------------------------------------------------------------

  default:
    cmds:
      - echo "{{.GREETING}}"
    silent: true

  # -------------------------------------------------------------------------
  # DATABASE TASKS
  # -------------------------------------------------------------------------

  # Builds the custom MySQL image from the Dockerfile
  build-db:
    desc: "Builds the custom MySQL image with pre-loaded schema."
    dir: docker
    cmds:
      - echo "Building image {{.IMAGE_NAME}}:{{.IMAGE_TAG}}"
      - docker build -t {{.IMAGE_NAME}}:{{.IMAGE_TAG}} .
    sources:
      # These files trigger a rebuild if changed
      - Dockerfile
      - mysql/01-init.sql
    silent: true

  # Starts the custom MySQL container
  start-db:
    desc: "Starts the MySQL container in the background."
    cmds:
      - echo "Starting container {{.CONTAINER_NAME}} on port {{.MYSQL_PORT}}"
      - |
        if docker ps -a -f name={{.CONTAINER_NAME}} --format '{{.Names}}' | grep -q {{.CONTAINER_NAME}}; then
          echo "Container exists. Starting it..."
          docker start {{.CONTAINER_NAME}}
        else
          echo "Creating and starting new container..."
          docker run -d \
            --name {{.CONTAINER_NAME}} \
            -p {{.MYSQL_PORT}}:3306 \
            -e MYSQL_ROOT_PASSWORD={{.MYSQL_ROOT_PASSWORD}} \
            -e MYSQL_DATABASE={{.MYSQL_DATABASE}} \
            {{.IMAGE_NAME}}:{{.IMAGE_TAG}}
        fi
    # Dependencies ensure the image is built before attempting to run it
    deps:
      - build-db
    # This task should be skipped if the container is already running
    status:
      - docker ps -f name={{.CONTAINER_NAME}} --format '{{.Names}}' | grep -q {{.CONTAINER_NAME}}
    silent: true

  # Checks the MySQL container status
  status-db:
    desc: "Checks the status of the MySQL container."
    cmds:
      - |
        echo "Checking status of container: {{.CONTAINER_NAME}}"
        if docker ps -f name={{.CONTAINER_NAME}} --format '{{`{{.Names}}`}}' | grep -q {{.CONTAINER_NAME}}; then
          echo "✓ Container is RUNNING"
          docker ps -f name={{.CONTAINER_NAME}} --format "table {{`{{.Names}}\t{{.Status}}\t{{.Ports}}`}}"
        elif docker ps -a -f name={{.CONTAINER_NAME}} --format '{{`{{.Names}}`}}' | grep -q {{.CONTAINER_NAME}}; then
          echo "⚠ Container exists but is STOPPED"
          docker ps -a -f name={{.CONTAINER_NAME}} --format "table {{`{{.Names}}\t{{.Status}}`}}"
        else
          echo "✗ Container does NOT exist"
        fi
    silent: true

  # Tests the database initialization and permissions
  test-db:
    desc: "Tests database initialization, web user access, and permissions."
    deps:
      - start-db
    env:
      DB_PASS: "{{.MYSQL_WEB_PASSWORD}}"
    cmds:
      - |
        echo "Testing database initialization..."
        echo ""

        # Wait for MySQL to be fully ready (max 30 seconds)
        echo "⏳ Waiting for MySQL to be ready..."
        for i in {1..30}; do
          if docker exec {{.CONTAINER_NAME}} mysqladmin ping -h localhost -u root -p{{.MYSQL_ROOT_PASSWORD}} --silent 2>/dev/null; then
            echo "✓ MySQL is ready"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "✗ MySQL failed to start within 30 seconds"
            exit 1
          fi
          sleep 1
        done
        echo ""

        # Test 1: Connect as web user and SELECT data
        echo "TEST 1: SELECT query as 'web' user (should SUCCEED)"
        echo "-------------------------------------------------------"
        docker exec -e MYSQL_PWD="$DB_PASS" {{.CONTAINER_NAME}} \
          mysql -u {{.MYSQL_WEB_USER}} -D {{.MYSQL_DATABASE}} -e "SELECT id, title, expires FROM snippets;"
        if [ $? -eq 0 ]; then
          echo "✓ SELECT query succeeded"
        else
          echo "✗ SELECT query failed"
          exit 1
        fi
        echo ""

        # Test 2: Try to INSERT (should succeed)
        echo "TEST 2: INSERT query as 'web' user (should SUCCEED)"
        echo "-------------------------------------------------------"
        docker exec -e MYSQL_PWD="$DB_PASS" {{.CONTAINER_NAME}} \
          mysql -u {{.MYSQL_WEB_USER}} -D {{.MYSQL_DATABASE}} \
          -e "INSERT INTO snippets (title, content, created, expires) VALUES ('Test snippet', 'Test content', UTC_TIMESTAMP(), DATE_ADD(UTC_TIMESTAMP(), INTERVAL 1 DAY));"
        if [ $? -eq 0 ]; then
          echo "✓ INSERT query succeeded"
        else
          echo "✗ INSERT query failed"
          exit 1
        fi
        echo ""

        # Test 3: Try to DROP TABLE (should fail)
        echo "TEST 3: DROP TABLE as 'web' user (should FAIL with permission error)"
        echo "-------------------------------------------------------"
        docker exec -e MYSQL_PWD="$DB_PASS" {{.CONTAINER_NAME}} \
          mysql -u {{.MYSQL_WEB_USER}} -D {{.MYSQL_DATABASE}} \
          -e "DROP TABLE snippets;" 2>&1 | grep -q "DROP command denied"
        if [ $? -eq 0 ]; then
          echo "✓ DROP TABLE correctly denied (permissions working as expected)"
        else
          echo "✗ DROP TABLE was allowed (permissions are TOO permissive!)"
          exit 1
        fi
        echo ""

        # Test 4: Try GRANT command (should fail)
        echo "TEST 4: GRANT command as 'web' user (should FAIL with permission error)"
        echo "-------------------------------------------------------"
        docker exec -e MYSQL_PWD="$DB_PASS" {{.CONTAINER_NAME}} \
          mysql -u {{.MYSQL_WEB_USER}} -D {{.MYSQL_DATABASE}} \
          -e "GRANT ALL ON snippetbox.* TO 'web'@'localhost';" 2>&1 | grep -q "Access denied"
        if [ $? -eq 0 ]; then
          echo "✓ GRANT command correctly denied (permissions working as expected)"
        else
          echo "✗ GRANT command was allowed (permissions are TOO permissive!)"
          exit 1
        fi
        echo ""

        echo "========================================================="
        echo "✓ All database tests PASSED!"
        echo "========================================================="
    silent: true

  # Stops and removes the MySQL container
  stop-db:
    desc: "Stops and removes the MySQL container."
    cmds:
      - echo "Stopping and removing container {{.CONTAINER_NAME}}"
      - docker rm -f {{.CONTAINER_NAME}}
    # This task only runs if the container exists
    status:
      - test ! $(docker ps -a -q -f name={{.CONTAINER_NAME}})
    silent: true

  # -------------------------------------------------------------------------
  # DATABASE WEB UI (ADMINER) TASKS
  # -------------------------------------------------------------------------

  # Starts Adminer web UI for database management
  start-adminer:
    desc: "Starts Adminer web UI on port {{.ADMINER_PORT}}."
    deps:
      - start-db
    cmds:
      - echo "Starting Adminer web UI on http://localhost:{{.ADMINER_PORT}}"
      - |
        if docker ps -a -f name={{.ADMINER_CONTAINER_NAME}} --format '{{.Names}}' | grep -q {{.ADMINER_CONTAINER_NAME}}; then
          echo "Container exists. Starting it..."
          docker start {{.ADMINER_CONTAINER_NAME}}
        else
          echo "Creating and starting Adminer container..."
          docker run -d \
            --name {{.ADMINER_CONTAINER_NAME}} \
            --link {{.CONTAINER_NAME}}:db \
            -p {{.ADMINER_PORT}}:8080 \
            adminer:latest
        fi
        echo ""
        echo "========================================================="
        echo "✓ Adminer is running at: http://localhost:{{.ADMINER_PORT}}"
        echo "========================================================="
        echo "Login credentials:"
        echo "  System:   MySQL"
        echo "  Server:   db"
        echo "  Username: {{.MYSQL_WEB_USER}}"
        echo "  Password: {{.MYSQL_WEB_PASSWORD}}"
        echo "  Database: {{.MYSQL_DATABASE}}"
        echo "========================================================="
    status:
      - docker ps -f name={{.ADMINER_CONTAINER_NAME}} --format '{{.Names}}' | grep -q {{.ADMINER_CONTAINER_NAME}}
    silent: true

  # Checks Adminer container status
  status-adminer:
    desc: "Checks the status of the Adminer container."
    cmds:
      - |
        echo "Checking status of container: {{.ADMINER_CONTAINER_NAME}}"
        if docker ps -f name={{.ADMINER_CONTAINER_NAME}} --format '{{`{{.Names}}`}}' | grep -q {{.ADMINER_CONTAINER_NAME}}; then
          echo "✓ Adminer is RUNNING"
          docker ps -f name={{.ADMINER_CONTAINER_NAME}} --format "table {{`{{.Names}}\t{{.Status}}\t{{.Ports}}`}}"
          echo ""
          echo "Access Adminer at: http://localhost:{{.ADMINER_PORT}}"
        elif docker ps -a -f name={{.ADMINER_CONTAINER_NAME}} --format '{{`{{.Names}}`}}' | grep -q {{.ADMINER_CONTAINER_NAME}}; then
          echo "⚠ Adminer container exists but is STOPPED"
          docker ps -a -f name={{.ADMINER_CONTAINER_NAME}} --format "table {{`{{.Names}}\t{{.Status}}`}}"
        else
          echo "✗ Adminer container does NOT exist"
        fi
    silent: true

  # Stops and removes the Adminer container
  stop-adminer:
    desc: "Stops and removes the Adminer container."
    cmds:
      - echo "Stopping and removing container {{.ADMINER_CONTAINER_NAME}}"
      - docker rm -f {{.ADMINER_CONTAINER_NAME}}
    status:
      - test ! $(docker ps -a -q -f name={{.ADMINER_CONTAINER_NAME}})
    silent: true

  # -------------------------------------------------------------------------
  # COMBINED SERVICES TASKS
  # -------------------------------------------------------------------------

  # Starts both database and adminer
  start-services:
    desc: "Starts both MySQL database and Adminer web UI."
    deps:
      - start-db
      - start-adminer
    cmds:
      - echo ""
      - echo "========================================================="
      - echo "✓ All services are running!"
      - echo "========================================================="
    silent: true

  # Stops both database and adminer
  stop-services:
    desc: "Stops and removes both MySQL database and Adminer containers."
    deps:
      - stop-adminer
      - stop-db
    cmds:
      - echo "✓ All services stopped"
    silent: true

  # -------------------------------------------------------------------------
  # APPLICATION TASKS
  # -------------------------------------------------------------------------

  # Starts the Go web application (foreground)
  start-app:
    desc: "Starts the Go web application in the foreground."
    deps:
      - start-db
    cmds:
      - echo "Starting Go application on port {{.APP_PORT}}..."
      - go run ./cmd/web
    silent: true

  # Starts the Go web application in the background
  start-app-bg:
    desc: "Starts the Go web application in the background."
    deps:
      - start-db
    cmds:
      - echo "Starting Go application in background on port {{.APP_PORT}}..."
      - |
        # Check if already running
        if lsof -ti:{{.APP_PORT}} > /dev/null 2>&1; then
          echo "⚠ Application already running on port {{.APP_PORT}}"
          exit 0
        fi
        # Create runtime directory if it doesn't exist
        mkdir -p {{.RUNTIME_DIR}}
        # Start in background and save PID
        nohup go run ./cmd/web > {{.RUNTIME_DIR}}/app.log 2>&1 &
        echo $! > {{.RUNTIME_DIR}}/app.pid
        sleep 1
        if lsof -ti:{{.APP_PORT}} > /dev/null 2>&1; then
          echo "✓ Application started (PID: $(cat {{.RUNTIME_DIR}}/app.pid))"
          echo "  Logs: {{.RUNTIME_DIR}}/app.log"
        else
          echo "✗ Application failed to start. Check {{.RUNTIME_DIR}}/app.log"
          exit 1
        fi
    silent: true

  # Checks the Go application status
  status-app:
    desc: "Checks if the Go application is running."
    cmds:
      - |
        echo "Checking Go application status..."
        PID=$(lsof -ti:{{.APP_PORT}} 2>/dev/null || true)
        if [ -n "$PID" ]; then
          echo "✓ Application is RUNNING on port {{.APP_PORT}}"
          echo "  PID: $PID"
          if [ -f {{.RUNTIME_DIR}}/app.pid ]; then
            echo "  Logs: {{.RUNTIME_DIR}}/app.log"
          fi
        else
          echo "✗ Application is NOT running"
        fi
    silent: true

  # Stops the Go web application
  stop-app:
    desc: "Stops the running Go web application."
    cmds:
      - echo "Stopping Go application..."
      - |
        # Find and kill the process running on the app port
        PID=$(lsof -ti:{{.APP_PORT}})
        if [ -n "$PID" ]; then
          kill $PID
          echo "✓ Application stopped (PID: $PID)"
          # Clean up PID file if it exists
          rm -f {{.RUNTIME_DIR}}/app.pid
        else
          echo "⚠ No application running on port {{.APP_PORT}}"
        fi
    silent: true